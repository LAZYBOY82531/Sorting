namespace Sorting
{
    internal class Program
	{
		/*선형 정렬 3종 구현 원리 조사
		 * 선택정렬
		 * 제자리 정렬 알고리즘의 하나입니다.
		 * 선택정렬은 주어진 리스트 중에 최소값을 찾은 후 그것을 가장 맨 앞에
		 * 위치한 값과 교체를 한 후, 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로
		 * 교체하는 방식으로 리스트를 정렬합니다. 선택정렬은 알고리즘이 단순하며, 
		 * 사용할 수 있는 메모리가 제한적인 경우에 사용시 성능상의 이점이 있습니다.
		 * 
		 * 삽입정렬
		 * 삽입정렬은 자료배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된
		 * 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성시키는
		 * 알고리즘입니다. 배열이 길어질수록 효율이 떨어진다는 단점이 있으나 구현이
		 * 간단하다는 장점이 있습니다. 선택정렬이나 거품정렬과같은 O(n^2)알고리즘에
		 * 비교하여 두개보다 빠르며 안정정렬이고 제자리 알고리즘이라는 장점도 있습니다.
		 * 
		 * 버블정렬
		 * 시간복잡도가 앞에 두개의 정렬과 같이 O(n^2)로 상당히 느리지만 코드가 
		 * 앞에 두개의 정렬보다도 단순하기 때문에 자주 사용됩니다. 원소의 이동이
		 * 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어진 이름이라고
		 * 합니다. 이를 양방향으로 번갈아 수행하는 칵테일 정렬이라는 변형 정렬 또한
		 * 존제합니다. 
		 *  버블 정렬은 기본적으로 배열의 두 수를 선택한 뒤, 만약 그 두 수가 정렬되었다면
		 *  놔두고 아니라면 두 수를 바꾸는 방식으로 진행됩니다. 오름차순 이라면 a > b
		 *  내림차순이라면 a < b여야 정렬된 것으로 판단합니다. 이를 배열의 처음부터 
		 *  끝까지 배열에 아무 변화가 없을 때까지 반복합니다.
		 *  
		 *  
		 *  
		 *  분할정복정렬 3종 원리 조사
		 *  
		 *  힙정렬 
		 *  힙정렬이란 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법으로서,
		 *  내림차순 정렬을 위해서는 최소 힙을 구성하고 오름차순 정렬을 위해서는
		 *  최대 힙을 구성하면 됩니다.
		 *   처음 n개의 노드에 대한 완전 이진 트리를 구성합니다. 이때 루트 노드부터
		 *  전위순위로 구성합니다. 이후 정렬된 완전 이진 트리에서 값을 하나씩 빼오면서
		 *  정렬을 하면 됩니다.
		 *  
		 *  합병정렬
		 *  합병정렬 또는 병합정렬은 비교 기반 정렬 알고리즘입니다. 일반적인 방법으로
		 *  구현했을 때 이 정렬은 안정 정렬에 속하며, 분할 정복 알고리즘의 하나로 분류
		 *  됩니다. 존 폰 노이만이 1945년에 개발했다고 합니다. 
		 *   합병정렬은 정렬되지 않은 리스트를 각각 하나의 원소만 포함하는 n개의
		 *  부분리스트로 분할합니다. 부분리스트가 하나만 남을 때 까지 반복해서 병합하며
		 *  정렬된 부분리스트를 생성합니다. 마지막 남은 부분리스트가 정렬된
		 *  리스트가 됩니다.
		 *   합병정렬은 다른 정렬들과 달리 임시 배열을 사용 하므로(제자리 정렬이 아님)
		 *  메모리적인 부담이 주어집니다.
		 *  
		 *  퀵 정렬
		 *  퀵 정렬(Quicksort)은 찰스 앤터니 리처드 호어가 개발한 정렬 알고리즘입니다.
		 *  다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속합니다. 퀵 정렬은 
		 *  n개의 데이터를 정렬할 때, 최악의 경우에는 O(n2)번의 비교를 수행하고, 
		 *  평균적으로 O(n log n)번의 비교를 수행합니. 퀵 정렬의 내부 루프는 
		 *  대부분의 컴퓨터 아키텍처에서 효율적으로 작동하도록 설계되어 있고
		 *  (그 이유는 메모리 참조가 지역화되어 있기 때문에 CPU 캐시의 히트율이 
		 *  높아지기 때문입니다.), 대부분의 실질적인 데이터를 정렬할 때 제곱 시간이 
		 *  걸릴 확률이 거의 없도록 알고리즘을 설계하는 것이 가능하다고 합니다. 또한 
		 *  매 단계에서 적어도 1개의 원소가 자기 자리를 찾게 되므로 이후 정렬할 
		 *  개수가 줄어듭니다. 때문에 일반적인 경우 퀵 정렬은 다른 O(n log n) 
		 *  알고리즘에 비해 훨씬 빠르게 동작합니다. 이러한 이유로 퀵소트(빠른정렬)
		 *  라는 이름의 기원이 되었습니다. 그리고 퀵 정렬은 정렬을 위해 평균적으로 
		 *  O(log n)만큼의 memory를 필요로합니다. 이는 재귀적 호출로 발생하는 것이며
		 *  최악의 경우 O(n)의 공간복잡도를 보입니다.
		 *   퀵 정렬은 분할 정복 방법을 통해 리스트를 정렬합니다.
		 *  리스트 가운데서 하나의 원소를 고릅니다. 이렇게 고른 원소를 피벗이라고
		 *  합니다. 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는
		 *  피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 리스트를 둘로
		 *  나눕니다. 이렇게 리스트를 둘로 나누는 것을 분할이라고 합니다. 분할을 마친
		 *  뒤에 피벗은 더 이상 움직이지 않습니다. 분할된 두개의 작은 리스트에 대해 
		 *  재귀적(리스트의 크기가 0이나 1이 될때까지)으로 이 과정을 반복합니다. 
		 *  재귀 호출이 한번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가
		 *  정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있습니다.
		 *  
		 *   힙정렬은 추가적인 메모리를 필요로 하지 않으면서 항상 O(NlogN)의 시간
		 *  복잡도를 가집니다. O(NlogN)인 정렬중 가장 효율적인 정렬 방법이라고 할 수
		 *  있습니다. 퀵정렬의 경우 효율적이나 최악의 경우 시간이 오래걸린다는 단점이
		 *  있으나 힙 정렬의 경우 항상 O(NlogN)이 보장됩니다.
		 *   하지만 힙정렬은 이상적인 경우에 퀵정렬과 비교했을 때 똑같이 O(NlogN)이
		 *  나오긴 하나 실제 시간을 측정하면 퀵정렬보다 느리다고 합니다. 즉, 데이터의
		 *  상태에 따라서 다른 정렬들에 비해서 조금 느린편입니다. 또한, 안정성을 보장
		 *  받지 못합니다.
		 *   
		 *  병합정렬은 퀵 정렬과 비슷하게 원본 배열을 절반씩 분할해 가면서 정렬하는
		 * 정렬법 으로써 분할하는 과정에서 logN만큼의 시간이 소요됩니다. 즉
		 * 최종적으로 보게 되면 O(NlogN)이 됩니다. 또한 퀵 정렬과 달리 기준값을
		 * 설정하는 과정없이 무조건 절반으로 분할하기에 기준값에 따라 성능이 달라지는
		 * 경우가 없습니다. 따라서 항상 O(NlogN)이라는 시간복잡도를 가지게 됩니다.
		 *  하지만 병합정렬은 임시배열에 원본맵을 계속 옮겨주며 정렬을 하는 방식이기에
		 * 추가적인 메모리가 필요하다는 단점이 있습니다. 데이터가 최악인 면을
		 * 고려하면 퀵 정렬보다는 병합정렬이 훨씬 빠르기 때문에 병합정렬을 사용하는
		 * 것이 많지만, 추가적인 메모리를 할당할 수 없다면 병합정렬을 사용할 수 없기
		 * 때문에 퀵을 사용해야 할 때도 있습니다.
		 * 
		 *  퀵 정렬은 기준값인 피벗에 의한 분할을 통해 구현하는 정렬 방법으로, 분할
		 * 과정에서 logN이라는 시간이 소요되며, 전체적으로 O(NlogN)이란 시간복잡도
		 * 를 가지며 준수한 편입니다.
		 *  하지만 퀵 정렬은 기존값에 따라 시간복잡도가 크게 달라집니다. 기준값을 
		 * 이상적인 값으로 선택했다면 O(NlogN)의 시간복잡도를 가지지만, 최악의
		 * 기준값을 선택할 경우 O(N^2)의 시간복잡도를 가지게 됩니다. 또한 안정성을
		 * 보장 받지 못합니다.
		 */
		static void Main(string[] args)
        {
            Console.WriteLine("Hello,  World!"); 
		}
	}
}